# 第7章 純粋性, 不変性, 変更ポリシー


プログラム内の状態変更を最小限に抑える. `189`

## 7.1 純粋性

__純粋関数 (純粋性のルール)__
- 結果は引数として与えられた値からのみ計算される
- 関数の外部で変更される可能性のあるデータに一切依存しない
- 関数実行部の外側に存在する何かの状態を一切変更しない

コントロールできる範囲の外のデータに頼るような関数を書くことは, わざわざ混乱を招くためのレシピと言えます. `193`

## 7.2 純粋と不順を分離する

純粋な関数は, 入力値とそれに対応する予測出力値のテーブルデータを作成してテストします. 
純粋性を損なう原因原因となる他のJavaScriptのメソッドや関数としては, `Date.now`や`console.log`, そして`this`
やグローバル変数の使用も同じく原因として挙げられます. `193`

### 7.2.2 純粋性と参照透過性との問題

非常に動的な言語であるJavaScriptは, 引数の型や戻り値の型を矯正することなく関数を定義し,利用できます.
この型付けに対する緩さによる問題が発生することはありますが, 自分が何を行っているかを確実に知っていれば, この柔軟性
を上手に活用することも可能です. `196`

与えられる配列とインデックス番号が同じであれば, 常に同じ値を返す(参照透過性) `197`

### 7.2.3 純粋性と冪(べき)等性の関係

冪等性とは, あるアクションを何度行っても1度行った場合とまったく同じ効果をもたらす, という考え方です. `199`

## 7.3 不変性

関数型プログラミングにおける理想の状況とは, 可変なものが全く存在しないという状況です. もし不変性を中心に据えた制限的なポリシーでプログラミングを始める場合 結果的にできることの多さに驚くことになるでしょう. `203`


### 7.3.1 誰もいない森で気が倒れたら, 音がするでしょうか?

関数を抽象の基本的なユニットとしてみる利点は, その実装内容さえ「漏れる」ことがなければ, 関数内部の詳細な実装方法はまったく無関係であるということです. `204`


### 7.3.2 不変性と, その再帰との関係

伝統的な関数型言語におけるローカル変数は実際には全く「変数」ではなく, 不変であり,変更することができません. `205`

(ローカル変数を変更する際の注意点が存在します.)


### 7.3.3 防御的フリーズとクローン

JavaScriptの配列やオブジェクトは参照渡しであるため, 本当に不変なものは存在しません. 同様に, JavaScriptの
オブジェクトフィールドは常に参照可能であるため, これを不変にする簡単な方法は存在しません. `206`

すべてのオブジェクトはフリーズさせない限り可変であるというJavaScript言語の最上位のルールが存在します. `206`

`Object#freeze` は「浅い」操作だということです. つまり, `Object#freeze` はオブジェクトの一番上のレベルのみフリーズさせ,
ネストされたオブジェクトはフリーズしないということです. `207`

オブジェクトをフリーズすることは,サードパーティAPIを使用する場合に微妙なバグをもたらす可能性があります.
そのため、フリーズについてここまで説明したもの, フリーズは極力避けるべきです. `209`

したがって, 不変性を保つためにとりうる手段は実質的に以下の3点のいずれかに限定されることになります.

- 浅いコピーで十分である場合は, `_.clone` を使ってコピーする
- 深いコピーが必要な場合は`deepClone`を使う
- 純粋関数を使ってコードを記述する


### 7.3.4 関数レベルの不変性を意識する

変更の範囲をコントロールする方法は, 変更するものを分離しておくことです.
任意のオブジェクトをその場で変更するのではなく, オブジェクトをあらかじめコンテナに格納しておいて,　それを変更することです.

```js
// 直接
var being = {name: 'Lemonjon'};
being.name = 'Lemongrab';

// 関節
var container = contain({name: 'Lomonjon'});
container.set({name: 'Lemongrab'});

// 関数呼び出しの結果として返す
var container = contain({name: 'Lemonjon'});
container.update(merge, {name: 'Lemongrab'});
// 1. container#setのように値を直接書き換えるのではなく, 
//    現在値いくつかの引数を渡された関数呼び出しの結果によって変更がおこる
// 2. この関節処理を関数レベルで行うことにより, ドメイン特化された製薬チェック関数も含めて,
//    考えられるすべての関数によって値の変更が出来るようになりました.
```
JavaScript は変数を自由に変更できるため, 不変性が妨げられます. しかしプログラム内の特定の変更パターンに注意することによって, 限りなく不変に近づけることができます. `222`  

